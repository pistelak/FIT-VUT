<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META HTTP-EQUIV="Content-language" CONTENT="cs">
<TITLE>IJC: DU1 </TITLE>
</HEAD>
<BODY>

<H1>IJC: DU1</H1>

<HR>
<XMP>

Jazyk C                    DU1                         26.2.2015
----------------------------------------------------------------


                      Domácí úkol è.1


Termín odevzdání:  26.3.2015
 ètìte pokyny na konci tohoto textu
 Hodnocení celkem max. 15 bodù

Pøíklady: (budou opravovány v prostøedí Linux/GCC,
           LC_ALL=cs_CZ.utf8
           parametry pøekladu: -O2 -std=c99 -Wall -pedantic)

a) V rozhraní "bit-array.h" definujte pro pole bitù:
   Typ:
     typedef BitArray_t
       Typ bitového pole (pro pøedávání parametru do funkce)

   Makra:
     BA_create(jmeno_pole,velikost)
       definuje a nuluje pole (POZOR: MUSÍ _INICIALIZOVAT_ pole bez ohledu na
       to, zda je pole statické nebo automatické/lokální!  Vyzkou¹ejte si obì
       varianty, v programu pou¾ijte lokální pole.)
       Pø: BA_create(p,100);     // p = pole 100 bitù
           BA_create(q,100000L); // q = pole 100000 bitù

     BA_size(jmeno_pole)
       vrátí deklarovanou velikost pole v bitech

     BA_set_bit(jmeno_pole,index,výraz)
       nastaví zadaný bit v poli na hodnotu zadanou výrazem
       (nulový výraz == bit 0, nenulový výraz == bit 1)
       Pø: BA_set_bit(p,20,1);

     BA_get_bit(jmeno_pole,index)
       získá hodnotu zadaného bitu, vrací hodnotu 0 nebo 1
       Pø: if(BA_get_bit(p,i)==1) printf("1");
           if(!BA_get_bit(p,i))   printf("0");

   Kontrolujte meze polí. V pøípadì chyby volejte funkci
     FatalError("Index %ld mimo rozsah 0..%ld", (long)index, (long)mez).
   (Pou¾ijte modul error.c/error.h z pøíkladu b)

   Program musí fungovat na 32 (gcc -m32) i 64bitové platformì.

   Podmínìným pøekladem zajistìte, aby se pøi definovaném symbolu
   USE_INLINE místo tìchto maker definovaly inline funkce stejného jména
   v¹ude kde je to mo¾né (bez zmìn v následujícím testovacím pøíkladu!).
   USE_INLINE nesmí být definováno ve zdrojovém textu --
   pøekládá se s argumentem -D (gcc -DUSE_INLINE ...).

   Napi¹te pomocná makra DU1_GET_BIT_(p,i), DU1_SET_BIT_(p,i,b)
   pro indexování bitù v poli T *p nebo T p[NN] bez kontroly mezí,
   kde T je libovolný celoèíselný typ (char, unsigned short, ...).
   (Tato makra pak pou¾ijete v dalsích makrech a inline funkcích.)
   Pro va¹i implementaci pou¾ijte pole typu: unsigned long [].
   Implementace musí efektivnì vyu¾ívat pamì» (vyu¾ít ka¾dý
   bit pole a¾ na posledních max. X-1, pokud má unsigned long X bitù).

   Jako testovací pøíklad implementujte funkci, která pou¾ije algoritmus známý
   jako Eratostenovo síto (void Eratosthenes(BitArray_t pole);) a pou¾ijte ji
   pro výpoèet posledních 10 prvoèísel ze v¹ech prvoèísel od 2 do
   N=201000000 (201 milionù). (Doporuèuji program nejdøíve odladit pro N=100.)
   Funkci Eratosthenes napi¹te do samostatného modulu "eratosthenes.c".

   Budete pravdìpodobnì potøebovat zvìt¹it limit velikosti zásobníku.
   Na Unix-like systémech pou¾ijte pøíkaz ulimit -a pro zji¹tìní velikosti
   limitu a potom "ulimit -s zadana_velikost".

   Ka¾dé prvoèíslo tisknìte na zvlá¹tní øádek v poøadí
   vzestupném.  Netisknìte  nic  jiného  ne¾  prvoèísla (bude se
   automaticky  kontrolovat!).  Pro kontrolu správnosti prvoèísel
   mù¾ete pou¾ít program  factor (./prvocisla|factor).

   Zdrojový text programu se musí jmenovat "prvocisla.c" !
   Pøíkaz "make" musí vytvoøit obì varianty: prvocisla a prvocisla-inline
   (Pøi nesplnìní podmínek: a¾ 0 bodù.)

(7b)

Poznámky:  Eratosthenovo síto (pøibli¾ná specifikace):
   1) Nulujeme bitové pole  p  o rozmìru N, index i nastavit na 2
   2) Vybereme nejmen¹í index i, takový, ¾e p[i]==0. Potom je
      i prvoèíslo
   3) Pro v¹echny násobky i nastavíme bit p[n*i] na 1
      ('vy¹krtneme' násobky - nejsou to prvoèísla)
   4) i++; dokud nejsme za sqrt(N), opakujeme bod 2 a¾ 4
      (POZOR: sestavit s matematickou knihovnou parametrem -lm)
   5) Výsledek: v poli p jsou na prvoèíselných indexech hodnoty 0

   Efektivita výpoètu: cca 5s na Core2duo/2.8GHz/Linux64 (gcc -O2)
   Porovnejte efektivitu obou variant (makra vs. inline funkce).

</XMP>
<HR>
<XMP>

b) Napi¹te modul "error.c" s rozhraním v "error.h", který definuje
   funkci void Warning(const char *fmt, ...) a
   funkci void FatalError(const char *fmt, ...). Tyto funkce mají
   stejné parametry jako printf(); tisknou text "CHYBA: " a potom
   chybové hlá¹ení podle formátu fmt. V¹e se tiskne do stderr
   (funkcí vfprintf) a potom FatalError ukonèí program voláním
   funkce exit(1).  Pou¾ijte definice ze stdarg.h.

 * Napi¹te modul "ppm.c" s rozhraním "ppm.h",
   ve kterém definujete typ:
     struct ppm {
        unsigned xsize;
        unsigned ysize;
        char data[];    // RGB bajty, celkem 3*xsize*ysize
     };
   a funkce:
     struct ppm * ppm_read(const char * filename);
        naète obsah PPM souboru do touto funkcí dynamicky
        alokované struktury. Pøi chybì formátu pou¾ije funkci Warning
        a vrátí NULL.  Pozor na "memory leaks".

     int ppm_write(struct ppm *p, const char * filename);
        zapí¹e obsah struktury p do souboru ve formátu PPM.
        Pøi chybì pou¾ije funkci Warning a vrátí záporné èíslo.

    Mù¾ete doplnit dal¹í funkce, ale pro DU1 to není nutné.
    [Zamyslete se nad (ne)vhodností pou¾ití Warning a promyslete alternativní
    zpùsoby hlá¹ení chyb.]

    Mù¾ete omezit max. velikost obrazových dat vhodným implementaèním
    limitem (napø 5000*5000*3), aby bylo mo¾né pou¾ít statickou inicializaci
    BitArray pro následující testovací program.

    Popis formátu PPM najdete na Internetu, implementujte pouze
    binární variantu P6 s barvami 0..255 bez komentáøù:
      "P6" <ws>+
      <xsizetxt> <ws>+ <ysizetxt> <ws>+
      "255" <ws>
      <binarni data, 3*xsize*ysize bajtu RGB>
      <EOF>

  * Napi¹te testovací program "steg-decode.c", kde ve funkci main naètete ze
    souboru zadaného jako jediný argument programu obrázek ve formátu PPM
    a v nìm najdete ulo¾enou "tajnou" zprávu. Zprávu vytisknete na stdout.

    Zpráva je øetìzec znakù (char, vèetnì '\0') ulo¾ený po jednotlivých bitech
    (poèínaje LSb) na nejni¾¹ích bitech (LSb) vybraných bajtù barevných slo¾ek
    v datech obrázku. Dekódování ukonèete po dosa¾ení '\0'.
    Pro DU1 budou vybrané bajty urèeny prvoèísly -- pou¾ijte Eratostenovo síto
    podobnì jako v pøíkladu "prvocisla.c".

    Program pou¾ije FatalError v pøípadì chyby ètení souboru (chybný formát),
    v pøípadì, ¾e zpráva obsahuje netisknutelné znaky (pou¾ijte isprint) nebo
    není korektnì ukonèena '\0'.

    Pou¾ijte program "make" pro pøeklad/sestavení programu.
    Testovací pøíkaz:  ./steg-decode du1-obrazek.ppm

    Zájemci si mohou vytvoøit i program "steg-encode.c" (nehodnotí se).

(8b)

   Zaøiïte, aby pøíkaz "make" bez parametrù vytvoøil v¹echny spustitelné
   soubory pro DU1.  Pøi zmìnì kteréhokoli souboru musí pøelo¾it jen zmìnìný
   soubor a závislosti. Pokud bude Makefile vypadat jako skript odeètou se 4b.

</XMP>
Testovací obrázek: <A HREF="du1-obrazek.ppm">du1-obrazek.ppm</A>
<HR>
<HR>
<XMP>

Pøedmìt: Jazyk C                                  rev 18.2.2015

Obecné pokyny pro vypracování domácích úkolù

*  Pro úkoly v jazyce C pou¾ívejte ISO C99 (soubory *.c)
   Pou¾ití nepøenositelných konstrukcí není dovoleno.
   C11 nebudete potøebovat.

*  Úkoly zkontrolujte pøekladaèem napøíklad takto:
      gcc -std=c99 -pedantic -Wall -Wextra priklad1.c
   místo gcc mù¾ete pou¾ít i jiný pøekladaè
!  (nebude-li úkol podle normy ISO C99, bude za 0 bodù!)
   v  souvislosti s tím napi¹te do poznámky na zaèátku
   souboru jméno pøekladaèe, kterým byl program pøelo¾en
   (implicitní je verze GNU C instalovaná na serveru merlin).

*  Programy  pi¹te, pokud je to mo¾né, do jednoho zdrojového
   souboru. Dodr¾ujte pøedepsaná jména souborù.

*  Na zaèátek ka¾dého souboru napi¹te poznámku, která bude
   obsahovat jméno, fakultu, oznaèení pøíkladu a datum.

Pøíklad:
  // enum.c
  // Øe¹ení IJC-DU1, pøíklad a), 20.3.2111
  // Autor: Jaroslav Cimrman, FIT
  // Pøelo¾eno: gcc 4.9
  // ...popis pøíkladu - poznámky, atd

* Úkoly je nutné zabalit programem zip takto:
       zip xnovak99.zip *.c *.h Makefile

  Jméno xnovak99 nahradíte vlastním. ZIP neobsahuje adresáøe.
  Ka¾dý si zkontroluje obsah ZIP archivu jeho rozbalením v prázdném adresáøi
  a napsáním "make".

* Øe¹ení se odevzdává elektronicky v IS FIT

* Posílejte pouze nezbytnì nutné soubory -- ne *.EXE !

* Úkoly neodevzdané v termínu budou za 0 bodù.

* Opsané úkoly budou hodnoceny 0 bodù pro v¹echny zùèastnìné
  a to bez výjimky (+ bonus v podobì náv¹tìvy u disciplinární komise).


</XMP>
<HR>
<ADDRESS>
Poslední modifikace: <!-- begin flastmod -->
26. února 2015<!-- end -->
<BR>
Pokud naleznete na této stránce chybu, oznamte to dopisem na adresu
peringer AT fit.vutbr.cz
</ADDRESS>
</body>
</html>


